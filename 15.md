#第15章：注释
***
#####前言：
我们的程序通常伴随着大量的非正式文件包含在源代码中的文件注释。例如，
许多组织都有一个标准的前导码，它们放置在顶部的类源文件，包含的东西，如版权信息，
程序员的名字，日期的类创建，日期类是最后修改，当前修订号，等等。
其他注释可能反应了一个类或者一个方法的预期用途，或者使用的限制。可以提供其他注释，
用于处理外部工具，帮助管理和部署应用程序，例如在源代码管理系统中的版本控制，或部署描述符，
该应用程序服务器如何管理类。这些评论为基础的注释提供了有用的目的，但它们是非正式的和临时的。
一个更好的方式来记录这些东西是注释的程序元素，直接使用注释类型来描述的形式的注释。
注释类型以一个标准的和结构化的方式呈现信息，这是由工具来自动处理的。

我们使用的注释将在开发或者部署环境中所使用的工具所支持的。
注释主要来自于`java.lang.annotation`包中，下面的介绍也主要来自于那个。
***
###第1节：一个简单的注释例子

试想一个非正式且基于评价类型的前言注释：
```java
/*-------------------------------
  Created:          Jan 31 2005
  Created By:       James Gosling
  Last Modified:    Feb 9 2005
  Last Modified By: Ken Arnold
  Revision:         3
---------------------------------*/
public class Foo {
    // ...
}
```
你可以定义一个注释类来保存所有你想要的信息：
```java
@interface ClassInfo {
    String created();
    String createdBy();
    String lastModified();
    String lastModifiedBy();
    int revision();
}
```
注释类是一种特殊的接口，它由`interface`关键词之前的`@`字符[1]来指定。
注释用于程序中的元素，诸如一个类或是一个字段的描述。那些特殊注释元素的描述
往往会成为注释类中的方法。一个注释元素更像是一个域，它包含了每一个拥有此类注释
的元素的值。因此，`ClassInfo`注释包含了四个字符串类型的元素以及一个整形元素。
当注释一个程序元素时，你会提供每一个注释元素的具体值。注释事实上是一类修饰符，
它们可以显示在修饰符许出现的地方。下面是介绍你如何使用`ClassInfo`和
`Foo`类：

[1]`@`字符被使用的理由是它读起来就是：A-T，而这恰好是Annotations Type的缩写。
```java
@ClassInfo (
    created = "Jan 31 2005",
    createdBy = "James Gosling",
    lastModified = "Feb 9 2005",
    lastModifiedBy = "Ken Arnold",
    revision = 3
)
public class Foo {
    // ...
}
```

上面这个例子里，注释又一次由`@`字符引入，紧随其后的就是注释类名。
注释元素的值是由一个以`name = value`为陈述方式所形成的表，每一对陈述
都以逗号来分隔。正如上述例子所见，一个注释包含了太多文本信息，因而
程序本身的代码可能很容易被遮盖于其中。因此强烈推荐你总是在任何其他
修饰符之前先列举出注释内容，并且都以一行为分隔，当然，这也需要你坚持练习使用。

如果要使用`ClassInfo`注释，那么只要`Foo`资源被编辑过，
程序员就必须更新每一个变量的值。支持注释功能的开发工具可以自动完成这些更新。
***
###第2节：注释类

注释类是一类特殊的接口，如你所见，`interface`由`@`字符引入。
注释类型可以在任何接口能被声明的地方声明。也就是说，作为一个顶级的注释类型或嵌套在
其他类型可以具有相同的修饰符应用接口。特征注释类型的接口是一个小小的误导，
但是，除了借用一些语法和一些相关的使用规则，注释类型有点类似于正常使用的接口。

在注释类型中声明的方法被称为注释类型的元素。这些元素被严格的规则约束：

- 元素的类型可以是简单类型，字符串，一个枚举类型，其他注释类型，类（或类特定的通用调用），或者一个数组的一种。
- 元素不能声明任何参数。
- 该元素不能有一个抛出子句。
- 元素不能定义一个类型参数（也就是说，它不能是一个泛型方法）。



在本质上，一个注释类型的元素就像一个对象的域，
即实例化的每个程序元素的注释类型的应用。
这些域的值是由初始化时的标注应用或元素的默认值（如果它有一个的话）所决定的。


你可以用关键字`default`和一个合适的值组成的参数列表来给元素赋默认值。
例如，假设你要将一个修正数字表示为主要的和次要的修改的整数，
你可以定义以下的注释类型，该类型具有默认的数字1.0：
```java
@interface Revision {
    int major() default 1;
    int minor() default 0;
}
```
值本身必须是常量表达式或文本（如类文字），但不为空。

`Revision`注释类型可以用来注释类或接口。我们之后会告诉你如何执行这一点
以及其他注释类型的使用。特别是我们可以重新定义“classinfo”注释类型的使用：
```java
@interface ClassInfo {
    String created();
    String createdBy();
    String lastModified();
    String lastModifiedBy();
    Revision revision();
}
```
当我们第一次创建`Foo`类时我们可能已经使用了`ClassInfo`：
```java
@ClassInfo (
    created = "Jan 31 2005",
    createdBy = "James Gosling",
    lastModified = "Jan 31 2005",
    lastModifiedBy = "James Gosling",
    revision = @Revision
)
public class Foo {
    // ...
}
```
注意一个注释类型的元素的初始化表达式如何使用注释语法。
在这种情况下，`@Revision`用默认值初始化`major`和`minor`元素。
当`Foo`是之后被编辑时，修改元素将发生相应的变化，例如：
```java
@ClassInfo (
    created = "Jan 31 2005",
    createdBy = "James Gosling",
    lastModified = "Feb 9 2005",
    lastModifiedBy = "Ken Arnold",
    revision = @Revision(major = 3)
)
public class Foo {
    // ...
}
```
这次将`revision`更新至3.0，方法是指定主值，以及重新允许`minor`值变为默认值0。

一个注释类型可以有零个元素，在这种情况下，它被称为一个标记注释，类似于一个标记接口。
例如，注释类型java.lang.deprecated是一个不再被使用的用于识别程序元素的标记注释。
当一个被`@Deprecated`标注的程序元素使用时，编译器会发出警告（开发环境需要能识别注释）。

如果一个注释类型有一个单一元素，那么该元素应该被命名为`value`。
这允许一些将会在下一节中描述的语法型速记法。

在注释类型的形式有了进一步限制。
注释类型可能没有显式声明它扩展了另一个接口，但是所有的注释类型
都会隐式扩展`Annotation`接口。注释类型也不被允许作为泛型类型。
最后，注释类型不被允许直接或间接地有它自己类型的元素。


如果一个接口明确地扩展了`Annotation`，那么它并不是一类注释，同时，
`Annotation`本身也不是一个注释类型。
类似地，如果一个接口声明它扩展了自一个注释类型，该接口本身就不是一个注释类型。
扩展或实现注释类型是没有意义的，但如果你这样做，注释类型就只是一个
简单且包含方法声明（包括那些继承于`Annotation`）的接口。

最后，就像任何其他的接口一样，注释类型可以声明常量和（隐式）嵌套类型。
***
###第3节：注释元素

程序元素可以标注的都是那些修饰符可以指定：声明类型（类，接口，枚举，和注释类型），
字段声明，方法和构造函数声明，局部变量声明，甚至参数声明。还有一个专门的机制来注释包

正如你所看到的，注释元素你提供的注释类型应用的名字，
冠以`@`和随后的注释类型的每个元素的初始值设定项括号列表。
一个给定的程序元素只能注释一次，每一个注释类型。

如果注释类型是一个标记注释或如果它的所有元素有默认值，然后初始化列表可以省略。
例如，您可以标记为过时的方法：
```java
    @Deprecated
    public void badMethod() { /* ... */ }
```
同样，你可以指定初始化一个空的列表：
```java
    @Deprecated()
    public void badMethod() { /* ... */ }
```
否则当你看到ClassInfo时，每一个没有默认值的元素，你必须列出一个形式如同`name=value`初始值。
初始化的顺序是不重要的，但每个元素只能出现一次。。如果一个元素有一个默认值，则不需要出现，
但是你可以把它如果你想用一个具体的一个覆盖默认值，当你看到在classinfo有Revision注释类型。

如果一个元素有数组类型，那么它是一个数组的初始化表达式初始化。例如，
一个注释来跟踪应用于一个类的错误修复可能看起来像这样：
```java
    @interface BugsFixed {
        String[] bugIDs();
    }
```

目的是当每个错误是固定的，它的标识符附加到初始化列表为bugIDs。下面是如何使用：
```java
    @BugsFixed(bugIDs = { "457605", "532456"})
    class Foo { /* ... */ }
```
如果一个数组只有一个元素，那么你可以用一个简短的方法来初始化数组，用括号来分配数组元素。
例如，固定在Foo的第一个错误是注释这样：
```java
    @BugsFixed(bugIDs = "457605")
```
如果一个注释类型像BugsFixed一样，只有一个单一元素，然后命名元素值允许一些额外的速记：
```java
    @interface BugsFixed {
        String[] value();
    }
```
第一次使用上面的BugsFixed在你这可以简化成
```java
    @BugsFixed({ "457605", "532456"})
```
如果有一个单一的初始化表达式，则假定它初始化一个元素称为`value`。如果没有这个名字，
那么你将得到一个编译时错误。这与一个速记速记结合元素的数组，你可以重写第二使用BugsFixed是
```java
    @BugsFixed("457605")
```
在注释类型中，可以有一个以上的元素，并且仍然调用其中的一个value。如果你这样做，
所有其他元素都有默认值，那么你仍然可以使用速记的形式来初始化value元素。
然而，一旦你有一个以上的初始化表达式，你必须明确地命名每个元素。

最后，你可以注释一个注释类型。例如，`Documented`标记注释指出注释的程序元素应该具有它的`Document`注释，
应为文件本身就有注释：
```java
    @Documented
    @interface Documented { }
```
自注是从内的注释类型的注释类型元素完全不同，你知道的，是不允许的。
***
###第4节：限制注释适用性

注释可以出现在编译器允许的任何地方，但是你可以想象，不是每个注释都会对每个程序的元素和方
意义。所以我们可以使用`@Target`来限制他的适用范围。这种`@Target`被称为元注释。

这里的`Target`的注释类型是少数在`java.lang.annotation`的包里定义的注释类型之一。
它用于注释类并且指明它的适用范围。它有个单一的枚举类型的定义，遵循着下面叫value的约定
元素阵列。`ElementType`代表着不同种类的程序元素可以应用，并定义常数ANNOTATION_TYPE:

- `CONSTRUCTIOR`构造器的声明
- `FIELD`域声明（包括enum实例）
- `LOCAL_VARIABLE`局部变量的声明
- `METHOD`方法的声明
- `PACKAGE`包声明
- `PARAMETER`参数声明
- `TYPE`类，接口等声明

编译器将检查应用于程序元素的任何注释，被允许应用于该程序元素的类型。
例如下面的classInfo注释类型只适于`TYPE`，所以应该这样：
```java
    @Target(ElementType.TYPE)
    @interface ClassInfo {
        String created();
        String createdBy();
        String lastModified();
        String lastModifiedBy();
        Revision revision();
    }
```
现在如果你要用classInfo注释参数声明，你会得到一个编译错误。你也可以同时指定多个元素类型。
例如：
```java
    @Tatget({ElementType.FIELD,ElementTYpe.LOCAL_VARIABLE})
```
我们的Revision注释类型也可以注明：
```java
    @Target(ElementType.TYPE)
```
用来限制它适用于类型声明。如果一个注释类型没有`@Target`
元注释那么它将适用于任何地方
不要混淆注释类型的适用性，可与注释类型的可访问性混淆。如果一个注释是公开的，
那么它可以在任何地方使用，但它的适用性可能会限制它可以应用到哪些元素。
相反，如果你试图将它应用到合适的元素中，你就无法应用它的注释。
限制注释的适用性不影响其在其他注释类型中的使用。
例如，如果Revision被限制在局部变量（没有意义），这并不阻止ClassInfo
有个Revision的元素。
***
###第5节：保留策略

注释可以为许多不同的目的服务，并可能用于不同的读者。
你所看到的大部分注释都是由程序员来读，或者说是开发工具。
其他的，如`@Deprecated`，用于编译器读取。在某些情况下，
一个工具可能需要从一个类的二进制表示中提取注释，
例如确定应用程序如何部署。有时需要在运行时进行检查。

与每一个注释类型相关联的是一个保留策略，也就是`@Retetion`，该策略确定该注释何时可访问。
这保留政策是由RetentionpPolicy枚举定义，并以Retention元注释的使用控制。
有三个保留策略值：

- `SOURCE`仅存在于源文件中，并且在生成二进制表示时会被编译器丢弃。
- `CLASS`注释被保留在类的二进制表示中，但在运行时不需要可使用。
- `RUNTIME`保存在类的二进制表示中，并且必须在运行时通过反射机制在运行时可用。

默认保留策略是`CLASS`。不管保留策略，在二进制表示或在运行时都不会使用局部变量的注释。
在二进制表示中没有地方可以存储信息。

在本质上，对于每个注释元素，运行时系统会创建一个对象，该对象实现了注释类型定义的接口。
通过调用该对象的相应方法，可以获得该程序元素的注释元素的值。

在为RUNTIME时反射机制的小例子：
```java
    @Retention(RetentionPolicy.RUNTIME)
    public @interface UseCase {
        public int id();
        public String description() default "no description";
    }
    
    public class Test1 {
        @UseCase(id=17,description="this is a description")
	    public void test(){
		    System.out.println("niconiconi");
	    }
	    public static void main(String[] args){
		    Method[] method=Test1.class.getDeclaredMethods();
		    for(Method m:method){
			    UseCase uc=m.getAnnotation(UseCase.class);
			    if(uc!=null){
				    System.out.println("Found Use Case:"+uc.id()+" "+uc.description());
			    }
		    }
	    }
    }
```
***
###第6节：和注释工作

注释可以很强大，但它们很容易被误用。很容易实现过载时，
注释注释的数量和冗长的代码本身完全掩盖。注释的使用应该明智地。
与注释的二个问题是任何人都可以定义自己的。注释的一个关键的好处是他们的自动分析中的适用性，
一般是通过标注处理工具，或APT。但自动化是最有用的，如果有共同的，标准的注释。
虽然你已经看到如何定义注释类型，在实践中很少程序员应该定义自己的类型。
目前只有几个定义的注释类型：

- 元注释`@Target`和`@Retention`，你已经看到了 
- `Deprecated`和`@Documented`注释，你也已经看到了
- `Inherited`元注释表示注释应该继承。例如，例如，如果一个类Foo查询特定的注释类型，
不存在在foo，但是注释类型有`Inherited`元注释，然后Foo类的父类将查询，等等。
- `@Override`注释，它告诉编译器，一个方法是重写继承的超类中的方法。这允许编译器警告你，
如果你错误地重载的方法，而不是重载一切（一个共同的错误）。
- `suppresswarnings`注释告诉编译器忽略某些警告，如用于初始化注释字符串定义。不幸的是，
没有一组预定义的警告字符串，这意味着不同编译器之间的互操作可能是一个问题。

在这个地方没有标准，注释可以被有效利用。

最后，另一个潜在的问题是，他们可能会被误用，以改变他们所应用的代码的语义。
根据语言规范，“在java语言程序里，注释是不允许以任何方式影响程序的语义的。”
事实上，任何未被识别的注释都应该被编译器、虚拟机和任何其它注释处理工具所忽略。
然而，我们很容易看到，用一个合适的加工工具，注释可以用来实现一个风格的编程，
可以让人们创建专门的Java编程语言的方言来满足自己的特定需求。
如果程序成为依赖于专门的注释支持，那么，该平台的可移植性将被丢失。
